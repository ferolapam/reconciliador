name: ci

on:
push:
branches: [main]
pull_request:
branches: [main]

jobs:
build-test:
runs-on: ubuntu-latest
env:
# Garante imports "from app..." durante testes, se necessário
PYTHONPATH: ${{ github.workspace }}

steps:
  - name: Checkout repository
    uses: actions/checkout@v4
    
  - name: Setup Python 3.12
    uses: actions/setup-python@v4
    with:
      python-version: '3.12'
      
  - name: Show repository tree (debug)
    run: |
      echo "PWD: $(pwd)"
      echo "Tree (top):"
      ls -la
      echo "Tree (app):"
      ls -la app || true
      echo "Show requirements files (if they exist):"
      for f in app/requirements*.txt; do echo "---- $f"; sed -n '1,200p' "$f" || true; done
      
  - name: Upgrade pip and build tools
    run: python -m pip install --upgrade pip setuptools wheel
    
  # Instala dependências de tempo de execução
  - name: Install Runtime Requirements
    run: |
      if [ -f app/requirements.txt ]; then
        pip install --no-cache-dir -r app/requirements.txt -v
      else
        echo "::error::app/requirements.txt not found"
        ls -la
        exit 2
      fi
      
  # Instalar pacote editável localmente (garante imports 'from app.service import app')
  - name: Install Editable Package (pip -e .)
    run: |
      # Se houver pyproject.toml/setup.cfg, isso instala o pacote local
      python -m pip install --no-cache-dir -e .
      
  - name: Install Development Requirements (Tests)
    run: |
      if [ -f app/requirements-dev.txt ]; then
        pip install --no-cache-dir -r app/requirements-dev.txt -v
      else
        echo "WARNING: app/requirements-dev.txt not found"
      fi
      
  - name: Check fastapi and show packages (debug)
    run: |
      python - <<'PY'


import importlib.util
import sys
import pkg_resources

print("sys.path:", sys.path[:6])
print("fastapi spec:", importlib.util.find_spec("fastapi"))
try:
print("fastapi version:", pkg_resources.get_distribution("fastapi").version)
except Exception as e:
print("fastapi version: not available -", e)
PY
pip list --format=columns | sed -n '1,200p'

  - name: Run tests
    run: pytest -q
    
  # Passo Datadog para notificação do status final do CI
  - name: Notify Datadog (US5)
    if: always() 
    env:
      DD_API_KEY: ${{ secrets.DD_API_KEY }}
      DD_SITE: ${{ secrets.DD_SITE }}
      GITHUB_STATUS: ${{ job.status }}
      REPO: ${{ github.repository }}
      RUN_ID: ${{ github.run_id }}
    run: |
      # 1. Instala o 'jq' (necessário para montar o JSON payload)
      sudo apt-get update && sudo apt-get install -y jq

      # 2. normaliza o SITE (remove prefixos e sufixos)
      SITE="${DD_SITE#https://}"
      SITE="${SITE%/}"

      # 3. monta payload
      STATUS="${GITHUB_STATUS:-success}"
      ALERT="success"
      if [ "$STATUS" != "success" ]; then ALERT="error"; fi

      TITLE="CI • ${REPO} • build-test"
      TEXT="GitHub Actions run #${RUN_ID} finalizado com status: ${STATUS}"

      PAYLOAD=$(jq -n --arg title "$TITLE" --arg text "$TEXT" --arg alert "$ALERT" --arg repo "$REPO" \
        '{title:$title, text:$text, alert_type:$alert, tags:["source:github","env:ci",("repo:"+$repo)]}')

      echo "Datadog host resolvido: api.${SITE}"

      # 4. envia evento (cabeçalho DD-API-KEY, sem query string)
      curl -sS -X POST "https://api.${SITE}/api/v1/events" \
        -H "Content-Type: application/json" \
        -H "DD-API-KEY: ${DD_API_KEY}" \
        --data "$PAYLOAD" \
        -o /tmp/dd_resp.json -w "HTTP_STATUS:%{http_code}\n"

      echo "Resposta Datadog:"
      cat /tmp/dd_resp.json || true
